<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>The 2026 ACIC Data Challenge – ACIC2026 Data Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-d6bf66eab951e3e2facc2c9e15467c3e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">ACIC2026 Data Challenge</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#data-background" id="toc-data-background" class="nav-link" data-scroll-target="#data-background">Data Background</a>
  <ul class="collapse">
  <li><a href="#covariates" id="toc-covariates" class="nav-link" data-scroll-target="#covariates">Covariates</a></li>
  <li><a href="#target-estimands" id="toc-target-estimands" class="nav-link" data-scroll-target="#target-estimands">Target Estimands</a></li>
  </ul></li>
  <li><a href="#registration-competition-timing" id="toc-registration-competition-timing" class="nav-link" data-scroll-target="#registration-competition-timing">Registration &amp; Competition Timing</a></li>
  <li><a href="#preparing-your-submission" id="toc-preparing-your-submission" class="nav-link" data-scroll-target="#preparing-your-submission">Preparing Your Submission</a>
  <ul class="collapse">
  <li><a href="#textrmicate-evaluations" id="toc-textrmicate-evaluations" class="nav-link" data-scroll-target="#textrmicate-evaluations"><span class="math inline">\(\textrm{iCATE}\)</span> Evaluations</a></li>
  <li><a href="#textrmscate-evaluations" id="toc-textrmscate-evaluations" class="nav-link" data-scroll-target="#textrmscate-evaluations"><span class="math inline">\(\textrm{sCATE}\)</span> Evaluations</a></li>
  <li><a href="#textrmsubcate-evaluations" id="toc-textrmsubcate-evaluations" class="nav-link" data-scroll-target="#textrmsubcate-evaluations"><span class="math inline">\(\textrm{subCATE}\)</span> Evaluations</a></li>
  <li><a href="#textrmpate-evaluations" id="toc-textrmpate-evaluations" class="nav-link" data-scroll-target="#textrmpate-evaluations"><span class="math inline">\(\textrm{PATE}\)</span> Evaluations</a></li>
  <li><a href="#best-textrmicate" id="toc-best-textrmicate" class="nav-link" data-scroll-target="#best-textrmicate">Best <span class="math inline">\(\textrm{iCATE}\)</span></a></li>
  <li><a href="#best-textrmscate" id="toc-best-textrmscate" class="nav-link" data-scroll-target="#best-textrmscate">Best <span class="math inline">\(\textrm{sCATE}\)</span></a></li>
  <li><a href="#best-textrmsubcate" id="toc-best-textrmsubcate" class="nav-link" data-scroll-target="#best-textrmsubcate">Best <span class="math inline">\(\textrm{subCATE}\)</span></a></li>
  <li><a href="#best-textrmpcate" id="toc-best-textrmpcate" class="nav-link" data-scroll-target="#best-textrmpcate">Best <span class="math inline">\(\textrm{pCATE}\)</span></a></li>
  <li><a href="#multiple-submissions" id="toc-multiple-submissions" class="nav-link" data-scroll-target="#multiple-submissions">Multiple Submissions</a></li>
  </ul></li>
  <li><a href="#questions-contact" id="toc-questions-contact" class="nav-link" data-scroll-target="#questions-contact">Questions &amp; Contact</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The 2026 ACIC Data Challenge</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>After a multiyear hiatus, we are excited to announce the return of the ACIC Data Challenge. This year the challenge will focus on the complications that arise in situations with multiple treatments. This will help us to understand how causal inference approaches handle the competing demands of settings with a wide variety of estimands. What’s the best approach to avoiding overconfidence in situations involving multiple, dependent comparisons? Can the same method yield strong results for both ATEs and subgroup effects? What are the tradeoffs between accurately estimating the effects of different treatments versus determining which of those treatments is most efficacious? We hope to address questions like these and more!</p>
<p>In addition, a key goal this year is to create a more inclusive competition by lowering the barriers to entry with regard to computing power and level of automation. To that end, our datasets will all be reasonably small and we provide an optional submission track for only 18 representative datasets.</p>
<p>Submissions will be due on April 20, 2026. We will announce the results at ACIC in May!</p>
</section>
<section id="data-background" class="level2">
<h2 class="anchored" data-anchor-id="data-background">Data Background</h2>
<p>For the Data Challenge, we have created 9000 different datasets, each of which was drawn from a distinct large population. These populations differ not only in terms of the treatment assignment probabilities but also in terms of the size of the treatment effects and the complexity/heterogeneity/functional form of the (conditional) average treatment effect functions. However, you may assume that treatment was assigned completely at random within each population. So, standard assumptions of ignorability and overlap are satisfied. You may also assume that Stable Unit Treatment Value Assumption (SUTVA) is satisfied. Across all populations, you may assume that <span class="math inline">\(a\)</span> represents the control or “business as usual” condition and that <span class="math inline">\(b, c, d, e\)</span> represent different treatment arms.</p>
<p>Each dataset contains <span class="math inline">\(n\)</span> triplets <span class="math inline">\((\boldsymbol{\mathbf{x}}_{i}, z_{i}, y_{i})\)</span> of $p = $ covariates <span class="math inline">\(\boldsymbol{\mathbf{X}}\)</span>, treatment indicator <span class="math inline">\(Z \in \{a,b,c,d,e\},\)</span> and outcome <span class="math inline">\(Y.\)</span> You may assume that these triplets were drawn from a much larger population of size <span class="math inline">\(N \gg n.\)</span></p>
<section id="covariates" class="level3">
<h3 class="anchored" data-anchor-id="covariates">Covariates</h3>
<p>There are continuous, binary, and nominal covariates. You may assume that the distributions of the covariates are the same across all populations considered in this challenge.</p>
</section>
<section id="target-estimands" class="level3">
<h3 class="anchored" data-anchor-id="target-estimands">Target Estimands</h3>
<p>Formally, each individual in the population has five potential outcomes <span class="math inline">\(Y_{i}(a), Y_{i}(b), Y_{i}(c), Y_{i}(d), Y_{i}(e)\)</span>, out of which exactly one is observed: <span class="math inline">\(y_{i} = Y_{i}(z_{i}).\)</span> We will be interested in estimating four types of average treatment effects. First, we would like to estimate for each observed individual in the sample <span class="math inline">\(i = 1, \ldots, n,\)</span> their individual-level conditional average treatment effect for each <span class="math inline">\(z \in \{b,c,d,e\}\)</span>: <span class="math display">\[
\textrm{iCATE}(\boldsymbol{\mathbf{x}}_{i}, z) = \mathbb{E}[Y_{i}(z) - Y_{i}(a) \vert \boldsymbol{\mathbf{X}} = \boldsymbol{\mathbf{x}}_{i}].
\]</span> The second type of effect is the sample-level conditional average treatment effect for each <span class="math inline">\(z \in \{b,c,d,e\}.\)</span> <span class="math display">\[
\textrm{sCATE}(z) = n^{-1}\sum_{i = 1}^{n}{\mathbb{E}[Y_{i}(z) - Y_{i}(a) \vert \boldsymbol{\mathbf{X}} = \boldsymbol{\mathbf{x}}_{i}]}.
\]</span></p>
<p>The third type of effect is the subgroup-specific sample-level conditional average treatment effect within subgroups defined by the value of <span class="math inline">\(X_{12} \in \{0,1\}\)</span> for each <span class="math inline">\(z \in \{B,C,D,E\}\)</span>: <span class="math display">\[
\textrm{subCATE}(z,x) = n^{-1}\sum_{i=1}^{n}{\mathbb{E}[Y_{i}(z) - Y_{i}(a) \vert \boldsymbol{\mathbf{X}} = \boldsymbol{\mathbf{x}}_{i}] \times \mathbf{1}(x_{i,12} = x)}.
\]</span> The fourth effect is the population average treatment effect for each <span class="math inline">\(z \in \{B,C,D,E\}\)</span>: <span class="math display">\[
\textrm{PATE}(z) = N^{-1}\sum_{i = 1}^{N}{Y_{i}(z) - Y_{i}(a)}.
\]</span></p>
<p>In addition to computing point estimates and pointwise uncertainty intervals for each of these effects, we are interested in determining which treatment is most effective relative to <span class="math inline">\(a\)</span>, where positive treatment effect values are considered better/more effective than negative values. Specifically, we wish to compute the most effective treatment for</p>
<ul>
<li>Each individual <span class="math inline">\(i = 1, \ldots, n\)</span> in the sample: <span class="math inline">\(\boldsymbol{\mathbf{x}}\)</span>, <span class="math inline">\(\textrm{argmax}_{z} \textrm{iCATE}(\boldsymbol{\mathbf{x}}_{i}, z).\)</span></li>
<li>On average, across the observed sample:<span class="math inline">\(\textrm{argmax}_{z} \textrm{sCATE}(z)\)</span></li>
<li>On average, across the observed sample, within each subgroup defined by<span class="math inline">\(X_{12} \in \{0,1\}:\)</span> <span class="math inline">\(\textrm{argmax}_{z} \textrm{subCATE}(z,x).\)</span></li>
<li>On average, across the whole population: <span class="math inline">\(\textrm{argmax}_{z} \textrm{PATE}(z).\)</span></li>
</ul>
</section>
</section>
<section id="registration-competition-timing" class="level2">
<h2 class="anchored" data-anchor-id="registration-competition-timing">Registration &amp; Competition Timing</h2>
<p>To participate in the competition at least one participant of every team needs to be a member of the Society for Causal Inference (see <a href="https://sci-info.org/membership/">here</a> for details on how to become a member of SCI). Please register for the challenge <strong>by April 1, 2026</strong> using this <a href="https://docs.google.com/forms/d/e/1FAIpQLSe9I5Co3ngnBD-snMdbW8f27ngbezh-t_gPI44ii-66cRwcbg/viewform?usp=sharing&amp;ouid=105756037255954774746">form</a>. Registration will provide you access to the data and allow us to assign you a team number (up to 5 submissions per team).</p>
<p>We will host two submission tracks:</p>
<ul>
<li>Curated: this track focuses on 18 datasets that are representative of the challenges created for this competition</li>
<li>The Works: Submit results for all 9000 datasets.</li>
</ul>
</section>
<section id="preparing-your-submission" class="level2">
<h2 class="anchored" data-anchor-id="preparing-your-submission">Preparing Your Submission</h2>
<p>For each dataset you analyze, you should create a separate CSV file containing estimates and, in the case of the <span class="math inline">\(\textrm{iCATE}, \textrm{sCATE},\)</span> <span class="math inline">\(\textrm{subCATE},\)</span> and <span class="math inline">\(\textrm{PATE}\)</span> evaluations, uncertainty intervals. Refer to the following sections for details about how to name and organize these files. For all estimands and datasets, you will need to include the following information in the submission filename:</p>
<ul>
<li><code>dataID</code>: dataset ID. Each dataset is stored in a file named something like <code>"data_dataID.csv"</code>, where <code>dataID</code> is a 4 digit number running from <code>0001</code> to <code>9000</code>.</li>
<li><code>teamID</code>: a unique ID number assigned to each submission team. Team numbers will be assigned no later than April 1, 2026 by the organizers.</li>
<li><code>submissionID</code>: if you enter multiple submissions, you will need to include a numeric id so that we can tell your submissions apart. See below for more details about multiple submissions.</li>
</ul>
<p>Please create a single compressed <code>.zip</code> or <code>.tar.gz</code> archive containing all your submission files, a README file containing a short, narrative description of your solution, and (optionally) reproducible code. The README file can be in plain-text, (R)Markdown, Quarto, or PDF file. Submissions without a README will not be considered for discussion at the ACIC meeting or in any follow-up article describing the competition. Your compressed archive should named <code>teamID_submissionID.zip</code> or <code>temaID_submission_ID.tar.gz</code>.</p>
<section id="textrmicate-evaluations" class="level3">
<h3 class="anchored" data-anchor-id="textrmicate-evaluations"><span class="math inline">\(\textrm{iCATE}\)</span> Evaluations</h3>
<p>For each dataset, submit a single CSV file containing point estimates and uncertainty intervals for the individual conditional average treatment effect functions evaluated at each observed covariate vector. These outputs should be arranged in “long” format with the following five named columns:</p>
<ul>
<li>“ID”: the observation identifier (numeric)</li>
<li>“z”: treatment arm (i.e., “b”, “c”, “d”, or “e”) that is being contrasted with “a”, the business as usual/control condition (character).</li>
<li>“Estimate”: the point estimate for <span class="math inline">\(\textrm{iCATE}(\boldsymbol{\mathbf{x}}_{\textrm{ID}}, \textrm{z}).\)</span></li>
<li>“L95”: the lower bound for a 95% uncertainty interval for the corresponding CATE evaluation</li>
<li>“U95”: the upper bound for a 95% uncertainty interval for the corresponding CATE evaluation</li>
</ul>
<p>The CSV file should be named <code>"iCATE_dataID_teamID_submissionID.csv"</code>. If the dataset contains <span class="math inline">\(n\)</span> observations, this file should contain <span class="math inline">\(4n + 1\)</span> rows, where the first row contains the header/column names.</p>
</section>
<section id="textrmscate-evaluations" class="level3">
<h3 class="anchored" data-anchor-id="textrmscate-evaluations"><span class="math inline">\(\textrm{sCATE}\)</span> Evaluations</h3>
<p>For each dataset, submit a single CSV file containing point estimates and uncertainty intervals for the sample average conditional average treatment effect functions. These outputs should be arranged in “long” format with the following four named columns:</p>
<ul>
<li>“z”: treatment arm (i.e., “b”, “c”, “d”, or “e”) that is being contrasted with “a”, the business as usual/control condition (character).</li>
<li>“Estimate”: the point estimate for <span class="math inline">\(\textrm{sCATE}(\textrm{z})\)</span> (numeric).</li>
<li>“L95”: the lower bound for a 95% uncertainty interval for the corresponding CATE evaluation (numeric).</li>
<li>“U95”: the upper bound for a 95% uncertainty interval for the corresponding CATE evaluation (numeric).</li>
</ul>
<p>The CSV file should be named <code>"sCATE_dataID_teamID_submissionID.csv"</code> and should contain 5 rows (including the header/column names).</p>
</section>
<section id="textrmsubcate-evaluations" class="level3">
<h3 class="anchored" data-anchor-id="textrmsubcate-evaluations"><span class="math inline">\(\textrm{subCATE}\)</span> Evaluations</h3>
<p>For each dataset, submit a single CSV file containing point estimates and uncertainty intervals for the average treatment effect within subgroups defined by <span class="math inline">\(X_{12} \in \{0,1\}\)</span> These outputs should be arranged in “long” format with the following named columns</p>
<ul>
<li>“z”: treatment arm (i.e., “b”, “c”, “d”, or “e”) that is being contrasted with “a”, the business as usual/control condition (character).</li>
<li>“x”: the value of <span class="math inline">\(X_{12}\)</span> (i.e., 0 or 1) (numeric)</li>
<li>“Estimate”: the point estimate for <span class="math inline">\(\textrm{subCATE}(\textrm{z}, x)\)</span> (numeric).</li>
<li>“L95”: the lower bound for a 95% uncertainty interval for the corresponding GATE evaluation (numeric).</li>
<li>“U95”: the upper bound for a 95% uncertainty interval for the corresponding GATE evaluation (numeric).</li>
</ul>
<p>The CSV file should be named <code>"subCATE_dataID_teamID_submissionID.csv"</code> and should only have 9 rows (including the header/column names).</p>
</section>
<section id="textrmpate-evaluations" class="level3">
<h3 class="anchored" data-anchor-id="textrmpate-evaluations"><span class="math inline">\(\textrm{PATE}\)</span> Evaluations</h3>
<p>For each dataset, submit a single CSV file containing point estimates and uncertainty intervals for the population average treatment effect. These outputs should be arranged into the following columns</p>
<ul>
<li>“z”: treatment arm (i.e., “b”, “c”, “d”, or “e”) that is being contrasted with “a”, the business as usual/control condition (character)</li>
<li>“Estimate”: the point estimate for <span class="math inline">\(\textrm{PATE}(\textrm{z}).\)</span> (numeric)</li>
<li>“L95”: the lower bound for a 95% uncertainty interval for the corresponding GATE evaluation (numeric)</li>
<li>“U95”: the upper bound for a 95% uncertainty interval for the corresponding GATE evaluation (numeric)</li>
</ul>
<p>The CSV file should be named <code>"PATE_dataID_teamID_submissionID.csv"</code> and should only have 5 rows (including the header/column names).</p>
</section>
<section id="best-textrmicate" class="level3">
<h3 class="anchored" data-anchor-id="best-textrmicate">Best <span class="math inline">\(\textrm{iCATE}\)</span></h3>
<p>For each dataset, submit a single CSV file identifying the treatment arm that is most effective, on average, relative to <span class="math inline">\(A\)</span> for each observed individual. These outputs should be arranged in “long” format with the following columns:</p>
<ul>
<li>“ID”: the observation identifier (numeric)</li>
<li>“best_z”: treatment arm <span class="math inline">\(z\)</span> (i.e., “b”, “c”, “d”, or “e”) that maximizes <span class="math inline">\(\textrm{iCATE}(\boldsymbol{\mathbf{x}}_{\textrm{ID}}, z)\)</span> (character)</li>
</ul>
<p>The CSV file should be named <code>"BEST_iCATE_dataID_teamID_submissionID.csv"</code>. The dataset contains <span class="math inline">\(n\)</span> observations, the submission file should have <span class="math inline">\(n+1\)</span> rows (including the header/column names).</p>
</section>
<section id="best-textrmscate" class="level3">
<h3 class="anchored" data-anchor-id="best-textrmscate">Best <span class="math inline">\(\textrm{sCATE}\)</span></h3>
<p>For each dataset, submit a single CSV file identifying the treatment arm that is most effective relative to A on average across the observed sample. These outputs should be arranged into the following columns:</p>
<ul>
<li>“best_z”: treatment arm <span class="math inline">\(z\)</span> (i.e., “b”, “c”, “d”, “e”) that maximizes <span class="math inline">\(\textrm{sCATE}(z)\)</span> (character).</li>
</ul>
<p>The CSV file should named <code>"BEST_sCATE_dataID_teamID_submissionID.csv"</code> and should contain 2 rows (including the header/column names).</p>
</section>
<section id="best-textrmsubcate" class="level3">
<h3 class="anchored" data-anchor-id="best-textrmsubcate">Best <span class="math inline">\(\textrm{subCATE}\)</span></h3>
<p>For each dataset, submit a single CSV file identifying the treatment arm that is most effective relative to <span class="math inline">\(A\)</span> within subgroups of the sample defined by <span class="math inline">\(X_{12}.\)</span> These outputs should be arranged in “long” format with the following columns:</p>
<ul>
<li>“x”: the value of <span class="math inline">\(X_{12}\)</span> (i.e., 0 or 1) (numeric).</li>
<li>“best_z”: treatment arm <span class="math inline">\(z\)</span> (i.e., “B”, “C”, “D”, or “E”) that maximizes <span class="math inline">\(\textrm{subCATE}(z,x)\)</span> (character).</li>
</ul>
<p>The CSV file should be named <code>"BEST_subCATE_dataID_teamID_submission_ID.csv"</code> and should include 2 rows (including the header/column names).</p>
</section>
<section id="best-textrmpcate" class="level3">
<h3 class="anchored" data-anchor-id="best-textrmpcate">Best <span class="math inline">\(\textrm{pCATE}\)</span></h3>
<p>For each dataset, submit a single CSV file identifying the treatment arm that is most effective relative to <span class="math inline">\(A\)</span> averaged across the whole population. These outputs should be arranged in “long” format with the following columns:</p>
<ul>
<li>“best_z”: treatment arm <span class="math inline">\(z\)</span> (i.e., “B”, “C”, “D”, or “E”) that maximizes <span class="math inline">\(\textrm{pCATE}(z)\)</span> (character)</li>
</ul>
<p>The CSV file should be named <code>"BEST_PATE_dataID_teamID_submission_ID.csv"</code> and should include 2 rows (including the header/column names).</p>
<p>Examples of different submission files are available <a href="">here</a>.</p>
</section>
<section id="multiple-submissions" class="level3">
<h3 class="anchored" data-anchor-id="multiple-submissions">Multiple Submissions</h3>
<p>Each team is welcome to make up to 5 different submissions. Please be sure you explain how these submissions differ in your submitted README files.</p>
</section>
</section>
<section id="questions-contact" class="level2">
<h2 class="anchored" data-anchor-id="questions-contact">Questions &amp; Contact</h2>
<p>If you have any questions, please do not hesitate to email us at acic2026datachallenge@gmail.com.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>